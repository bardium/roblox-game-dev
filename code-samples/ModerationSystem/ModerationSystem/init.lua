--!strict

local HttpService = game:GetService("HttpService")
local MessagingService = game:GetService("MessagingService")
local Players = game:GetService("Players")
local TextService = game:GetService("TextService")

local ModerationAction = require(script.ModerationAction)
local ModerationStatus = require(script.ModerationStatus)
local DataStoreWrapper = require(script.DataStoreWrapper)
local retryAsync = require(script.retryAsync)
local safePlayerAdded = require(script.safePlayerAdded)

local MESSAGING_KICK_TOPIC = "MODERATION_KICK"
local MESSAGING_ATTEMPTS = 3
local MESSAGING_RETRY_PAUSE_CONSTANT = 2
local MESSAGING_RETRY_PAUSE_EXPONENT_BASE = 2

local DATA_STORE_NAME = "MODERATION_DATA"
local DATA_STORE_KEY_TEMPLATE = "USER_%d"
local DATA_STORE_ATTEMPTS = 3
local DATA_STORE_RETRY_PAUSE_CONSTANT = 2
local DATA_STORE_RETRY_PAUSE_EXPONENT_BASE = 2

-- Create a new DataStoreWrapper to use for interfacing with DataStore
-- DataStoreWrapper elegantly handles errors and retries, using a queue system to ensure
-- that all requests are made in the correct order
local DATA_STORE_WRAPPER = DataStoreWrapper.new(
	DATA_STORE_NAME,
	DATA_STORE_ATTEMPTS,
	DATA_STORE_RETRY_PAUSE_CONSTANT,
	DATA_STORE_RETRY_PAUSE_EXPONENT_BASE
)

-- The maximum amount of previous moderation statuses stored per user
local MAX_HISTORY_STORED = 200

type KickData = {
	userId: number,
	reason: string?,
}

local ModerationSystem = {
	_initialized = false,
	_subscribedToKickTopic = false,
}

function ModerationSystem._initialize()
	assert(not ModerationSystem._initialized, "Already initialized!")

	-- Make sure moderation statuses are enforced on players who join or are already in the server
	safePlayerAdded(ModerationSystem._enforcePlayerStatusAsync)
	ModerationSystem._subscribeToKickTopicAsync()

	ModerationSystem._initialized = true
end

-- Subscribe to a MessagingService topic to process kicks from other servers
function ModerationSystem._subscribeToKickTopicAsync()
	assert(not ModerationSystem._subscribedToKickTopic, "Already subscribed to kick topic!")
	ModerationSystem._subscribedToKickTopic = true

	local success, result = retryAsync(function()
		MessagingService:SubscribeAsync(MESSAGING_KICK_TOPIC, function(message)
			local encodedData = message.Data
			if encodedData then
				local data = HttpService:JSONDecode(encodedData) :: KickData
				local player = Players:GetPlayerByUserId(data.userId)
				-- If the player is in this server, kick them
				if player then
					ModerationSystem._kickPlayerAsync(player, data.reason)
				end
			end
		end)
	end, MESSAGING_ATTEMPTS, MESSAGING_RETRY_PAUSE_CONSTANT, MESSAGING_RETRY_PAUSE_EXPONENT_BASE)

	if not success then
		warn(string.format("Failed to subscribe to kick topic because: %s", result))
	end
end

-- Return the filtered reason string or "" if the filter fails
-- Since this may be tied to mod commands or similar, it is important to filter ban/kick reasons
-- as they can be generated by one user and displayed to another
function ModerationSystem._getFilteredReasonAsync(reason: string, userId: number): string
	local success, result = pcall(function()
		local filterResult = TextService:FilterStringAsync(reason, userId) :: TextFilterResult
		return filterResult:GetNonChatStringForUserAsync(userId)
	end)

	return if success then result else ""
end

-- Get the current moderation status of a player and kick them if they have a ban active
function ModerationSystem._enforcePlayerStatusAsync(player: Player)
	local success, status = ModerationSystem.getUserModerationStatusAsync(player.UserId)
	if success and status then
		if status.action == ModerationAction.Ban then
			if not status:isExpired() then
				local message = status:getBanMessage()
				ModerationSystem._kickPlayerAsync(player, message)
			end
		end
	end
end

-- Kick a player for a specified reason, applying a filter to the reason string
function ModerationSystem._kickPlayerAsync(player: Player, reason: string?)
	if reason then
		local filteredReason = ModerationSystem._getFilteredReasonAsync(reason, player.UserId)
		player:Kick(filteredReason)
	else
		player:Kick()
	end
end

-- Get the current moderation status of a userId from DataStore
function ModerationSystem.getUserModerationStatusAsync(userId: number): (boolean, any?)
	local success, result = DATA_STORE_WRAPPER:getAsync(string.format(DATA_STORE_KEY_TEMPLATE, userId))

	if not success then
		return false
	end

	if result and result.status then
		local moderationStatus = ModerationStatus.new(
			result.status.action,
			result.status.date,
			result.status.permanent,
			result.status.duration,
			result.status.reason
		)
		return true, moderationStatus
	else
		return true, nil
	end
end

function ModerationSystem.getUserModerationHistoryAsync(userId: number): (boolean, { any }?)
	local success, result = DATA_STORE_WRAPPER:getAsync(string.format(DATA_STORE_KEY_TEMPLATE, userId))
	local history = {}

	if not success then
		return false
	end

	if result and result.history then
		for _, dataStoreStatusObject in result.history do
			local moderationStatus = ModerationStatus.new(
				dataStoreStatusObject.action,
				dataStoreStatusObject.date,
				dataStoreStatusObject.permanent,
				dataStoreStatusObject.duration,
				dataStoreStatusObject.reason
			)
			table.insert(history, moderationStatus)
		end
	end

	return success, history
end

-- Kick the player with the specified userId from any server
function ModerationSystem.kickUserAsync(userId: number, reason: string?)
	local player = Players:GetPlayerByUserId(userId)

	if player then
		ModerationSystem._kickPlayerAsync(player, reason)
	else
		local data = {
			userId = userId,
			reason = reason,
		} :: KickData
		local encodedData = HttpService:JSONEncode(data)

		retryAsync(function()
			MessagingService:PublishAsync(MESSAGING_KICK_TOPIC, encodedData)
		end, MESSAGING_ATTEMPTS, MESSAGING_RETRY_PAUSE_CONSTANT, MESSAGING_RETRY_PAUSE_EXPONENT_BASE)
	end
end

-- Set a ModerationStatus as the current status for the specified userId and add it to their moderation history
function ModerationSystem._applyStatusAsync(userId: number, status): boolean
	return DATA_STORE_WRAPPER:updateAsync(string.format(DATA_STORE_KEY_TEMPLATE, userId), function(oldData)
		local data = oldData or { history = {} }

		data.status = status:serialize()

		table.insert(data.history, data.status)
		if #data.history > MAX_HISTORY_STORED then
			table.remove(data.history, 1)
		end

		return data
	end)
end

-- Ban the specified userId from the game for a set duration
-- A duration of -1 will be treated as permanent
-- Ban reason is optional - if provided it will be displayed to the user when they attempt to join
function ModerationSystem.banUserAsync(
	userId: number,
	isPermanent: boolean,
	durationInSeconds: number,
	reason: string?
): boolean
	assert(math.floor(durationInSeconds) == durationInSeconds, "Duration must be an integer")
	assert(durationInSeconds >= 0, "Duration must be >= 0")
	-- Create a new ModerationStatus object
	local now = DateTime.now().UnixTimestamp
	local status = ModerationStatus.new(ModerationAction.Ban, now, isPermanent, durationInSeconds, reason)

	-- Update datastore
	local success = ModerationSystem._applyStatusAsync(userId, status)

	-- Kick player if they are online
	local message = status:getBanMessage()
	ModerationSystem.kickUserAsync(userId, message)

	return success
end

-- Unban the specified userId
function ModerationSystem.unbanUserAsync(userId: number): boolean
	local now = DateTime.now().UnixTimestamp
	local status = ModerationStatus.new(ModerationAction.Unban, now)

	-- Update datastore
	local success = ModerationSystem._applyStatusAsync(userId, status)

	return success
end

ModerationSystem._initialize()

return ModerationSystem
